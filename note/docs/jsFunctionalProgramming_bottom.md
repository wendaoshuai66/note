#JavaScript函数式编程--下

##函子

###回顾范畴与容器
1.我们可以把”范畴”想象成是一个容器，里面包含两样东西。值(value)、值的变形关系，也就是函数。

2.范畴论使用函数，表达范畴之间的关系。

3.伴随着范畴论的发展，就发展出一整套函数的运算方法。这套方法 起初只用于数学运算，后来有人将它在计算机上实现了，就变成了今 天的”函数式编程。

4.本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积 分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程 序。为什么函数式编程要求函数必须是纯的，不能有副作用?因为它 是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满 足函数运算法则了。

###函子

1.函数不仅可以用于同一个范畴之中值的转换们，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子(Functor)。

2.函子是函数式编程里面最重要的数据类型，也是基本的运算 单位和功能单位。它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。

![函子](https://wendaoshuai66.github.io/study/note/images/hanzi.png)

###容器与Functor（函子）

1.$(...) 返回的对象并不是一个原生的 DOM 对象，而是对于原生对象的一种封装，这在某种意义上就是一个“容器”(但它并不函数 式)。

2.Functor(函子)遵守一些特定规则的容器类型。

（1.）Functor 是一个对于函数调用的抽象，我们赋予容器自己去调用函数的能力。

（2.）把东西装进一个容器，只留出一个接口 map 给容器外的函数，map 一个函数时，我们让容器自己来运行这个函数，这样容器就可以自由地选择何时何地如何操作这个函数，以致于拥有惰性求值、错误处理、异步调用等等非常牛掰的特性。

废话不多说，上代码：

```
//Container就是容器
function Container(x){
  this._val = x
}
Container.of=x=>new Container(x);
//函子的标志就是容器里有一个map方法，将容器里的每一个值映射到另一个容器中
Container.prototype.map =function(f){
  return  Container.of(f(this._val))
}
var container=Container.of(3).map(x=>x+1)
console.log(container._val)//4
```

es6写法


```

class Functor{
    constructor(x){
        this._val = x
    }
    map(f){
        return new Functor(f(this._val))
    }
}
Functor.of=x=>new Functor(x)
var container=(new Functor(3)).map(x=>x+1)
var toUpperCase =(word)=>word.toUpperCase()
var container1 = Functor.of('abc').map(toUpperCase)
console.log(container1)
```

####map

上面代码中，Functor是一个函子，它的map方法接受函数f作为 参数，然后返回一个新的函子，里面包含的值是被f处理过的 (f(this.val))。 一般约定，函子的标志就是容器具有map方法。该方法将容器里 面的每一个值，映射到另一个容器。 上面的例子说明，函数式编程里面的运算，都是通过函子完 成，即运算不直接针对值，而是针对这个值的容器----函子。函 子本身具有对外接口(map方法)，各种函数就是运算符，通过 接口接入容器，引发容器里面的值的变形。 因此，学习函数式编程，实际上就是学习函子的各种运算。由 于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变 成了运用不同的函子，解决实际问题。

####of

你可能注意到了，上面生成新的函子的时候，用了 new命令。这实在太不像函数式编程了，因为new命令是 面向对象编程的标志。 函数式编程一般约定，函子有一个of方法，用来生成新 的容器。








#前端架构与性能优化那些事

##前端的性能到底对业务数据有多大的影响？

来个小故事

从前有个工程师，特别注重代码细节，有一天他发现系统中的一段代码写的性能很差，因此，他用汇编重写了整段代码，执行效率足足提升了三倍。但是最后，大家发现，用户反馈性能丝毫没有提高，因为他优化的那个进程名字叫“System Idle”。

所以你看，性能优化不能只着眼于局部的代码。这里，我要提出一个我的观点：<strong>一切没有 profiling 的性能都是耍流氓</strong>。凡是真正有价值的性能优化，必定是从端到端的业务场景建立体系来考虑的。

总结：性能体系的建立可以分成以下几部分：

1.现状评估和建立指标；

2.技术方案；

![](https://wendaoshuai66.github.io/study/note/images/技术方案.png)

3.执行；

4.结果评估和监控。


57%的⽤用户更更在乎⽹网⻚页在3秒内是否完成加载。
52%的在线⽤用户认为⽹网⻚页打开速度影响到他们对⽹网站的忠实度。
每慢1秒造成⻚页⾯面 PV降低11%，⽤用户满意度也随之降低降低16%。
近半数移动⽤用户因为在10秒内仍未打开⻚页⾯面从⽽而放弃。


##性能优化学徒

![](https://wendaoshuai66.github.io/study/note/images/xingnengyouhua.png)


几个核心是：压缩 ，合并，md5

使用HTML CSS HIND对HTML的数量进行控制，HTML数量如果多的话渲染的会比较慢，对HTML的数量进行严格把控，不能滥用HTML

使用多个CDN的资源，多个CDN的优势：一般大型网站Cookie会非常的长，Cookie比较烦的一点是每次请求会带去，然后后台response一个新的Cookie，那么这个Cookie可能就会带来带去的，那么这么大的东西每次请求带来带去的会比较头痛，然而静态资源不需要Cookie，那么就会使用到CDN；那么这就是CDN；CDN的功能不仅仅是多资源很快的定位做缓存，并且可以节省Cookie。

GZIP的开启一般是Nginx中设置----》gzip:on


###缓存优先级--服务器缓存策略

![](https://wendaoshuai66.github.io/study/note/images/huancunyouxianji.png)

![](https://wendaoshuai66.github.io/study/note/images/huancunyouxianji1.png)

为什么会有这么多缓存：浏览器发展，http的版本形态状态的设置。


优点：减少相应的延迟。减少网络带宽消耗。本地缓存不可控。

一般库文件才会使用http缓存，库文件一般不会频繁变动，所有一般是强缓

业务文件是一般是etag和离线缓存


###离线缓存--localstorage的使用

[https://github.com/addyosmani/basket.js](https://github.com/addyosmani/basket.js)

1.首先使用webpack-manifest-plugin，打印出md5.js

例如

```
{
  "a.js": "axx4.js",
  "omega.js": "mods/omega.0987654321.js"
}
```

2.本地缓存去取a.js

3.有激活js addScript

3-1 a.js -> axx2.js 对比

3-2更新流程 a.js -> axx4.js

3-3 删除 axx2.js

3-4 跳到下一步

4.没有

4-1 请求 axx4.js

4-1 axx4.js 放到缓存




###from memory cache与from disk cache

![](https://wendaoshuai66.github.io/study/note/images/mery.png)

1.浏览器Network的Size栏

在浏览器开发者工具的Network的Size栏会出现的三种情况：

from memory cache

from disk cache

资源本身大小（比如：13.6K)

2.三级缓存原理


1)、先查找内存，如果内存中存在，从内存中加载；

2)、如果内存中未查找到，选择硬盘获取，如果硬盘中有，从硬盘中加载；

3)、如果硬盘中未查找到，那就进行网络请求；

4)、加载到的资源缓存到硬盘和内存；


3.区别

根据系统的配置环境分配from memory cache或from disk cache

4.几种状态的执行顺序

现加载一种资源（例如：图片）：

访问-> 200 -> 退出浏览器

再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)


###http

http2出现也就可以放弃打包压缩那一步了

![](https://wendaoshuai66.github.io/study/note/images/http2duolu.png)

## 渲染中性能优化

###网页渲染流程

1-1.获取dom分割成多层 Parse HTML

1-2.对每个层计算样式结果 Recalculate Style

1-3 为每个节点生成图形和位置 重排 Layout

1-4 将每个节点绘制并填充到图层的位图中。重绘 Paint

1-5 绘制出来的纹理上传到GPU Composite Layers

2 大致流程 Layout  、Paint 、Composite Layers


3 网页分层

根元素 position transform 半透明 滤镜 canvas video overflow

GPU参与 参与好处：跨过 重排 重绘

CSS3d video webgl transform 滤镜

4.cpu gpu

相同点：两者总有总线和外界联系 ，有自己的缓存体系 以及数字和逻辑运算单元，为了完成计算任务而生的

不同点： cpu主要负责操作系统和应用程序。而gpu 负责和显示相关的 ，gpu能干的活cpu都能干只不过效率低

5.有些属性读会造成重排

重绘不一定引起重排，重排一定会引起重绘。

会引起重排属性：offset scroll width height 

建议dom读写分离 
读：ele.height ele.offset  

下一帧的时候再去设置相关的值 requestAnimationFrame requestIdleCallback(浏览器支持的不是很好)。60帧1000毫秒内渲染出来

##⻚页⾯面加载性能优化

![](https://wendaoshuai66.github.io/study/note/images/TTFB.png)

FP(First Paint) 首次绘制

FCP （First Contentful Paint）, ⾸次 有内容的绘制

FMP （First Meaningful Pain）  ⾸ 次有意义的绘制 没有绝对，自己决定

TTI （Time To Interactive）, 可交互 时间 整个页面ok


![](https://wendaoshuai66.github.io/study/note/images/tti.png)


![](https://wendaoshuai66.github.io/study/note/images/fmp.png)

![](https://wendaoshuai66.github.io/study/note/images/baiping.png)
```
<div class="container">
    <div class="ball" id="ball">ball</div>
</div>

const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log(entry);
    }
});

observer.observe({ entryTypes: ['paint'] })
```

PerformancePaintTiming {name: “first-paint”, entryType: “paint”, startTime: 16.30499999737367, duration: 0}

duration: 0

entryType: “paint”

FP

name: “first-paint”

startTime: 16.30499999737367

proto: PerformancePaintTiming

index.html:61

FCP

PerformancePaintTiming {name: “first-contentful-paint”, entryType: “paint”, startTime: 16.315000000759028, duration: 0}

duration: 0

entryType: “paint”

name: “first-contentful-paint”

startTime: 16.315000000759028

proto: PerformancePaintTiming

![](https://wendaoshuai66.github.io/study/note/images/longtask.png)
验证

```
let arr = [];
for (let i = 0; i < 10000000; i++) {
    arr.push(i)
}

const observer = new PerformanceObserver((list) => {
    for (const entry of list.getEntries()) {
        console.log(entry);
    }
});

observer.observe({ entryTypes: ['longtask'] })
```

PerformanceLongTaskTiming {attribution: Array(1), name: “self”, entryType: “longtask”, startTime: 12.879999994765967, duration: 303.82500000996515}

attribution: [TaskAttributionTiming]

duration: 303.82500000996515

longtask

entryType: “longtask”

name: “self”

startTime: 12.879999994765967

proto: PerformanceLongTaskTiming










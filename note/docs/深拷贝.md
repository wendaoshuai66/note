#对深拷贝的研究


##深拷贝和浅拷贝的定义

深拷贝：拷贝实例；浅拷贝：拷贝引用（原对象）。

####说深拷贝和浅拷贝之前，我先去了解了下高程书上的JavaScript的变量类型：

基本类型：undefined、null、Boolean、number、string。变量直接按指存放在栈区内，可以直接访问，所以我们平时把字符串、数字的值赋值给新变量，相当于把值完全复制过去，新变量的改变不会影响旧变量。
  
引用类型：存放在堆区的对象，变量在栈区中保存的是一个指针地址。

例子

```
   let a = 123;
   let b = a;
   b = 456;
   console.log(a);//123
   console.log(b);//456
```

深拷贝和浅拷贝图解

![](https://wendaoshuai66.github.io/study/note/images/拷贝图解.png)


将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

话不多说，浅拷贝就不再多说，下面我们直入正题：

##乞丐版

在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。

```
JSON.parse(JSON.stringify());
```

这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、拷贝正则、拷贝Date类型、循环引用等情况不行。

##基础版本1

```
//基础版本

function clone(target) {
    let cloneTarget = {};
    for (let i in target) {
        cloneTarget[i] = target[i]
    }
    return cloneTarget;
}
```


##基础版本2

创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。

如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：

如果是原始类型，无需继续拷贝，直接返回

如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。

很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝


```

function clone(target) {
    if (typeof target === "object") {
        let cloneTarget = {};
        for (let i in target) {
            cloneTarget[i] = clone(target[i])
        }
        return cloneTarget;
    } else {
        return target;
    }
}
let obj = {
    a: 1,
    b: {
        c: {
            d: function() {
                console.log(1)
            }
        }
    }
}
let obj1 = clone(obj)
obj1['b']['c']['d'] = 'ee'
console.log(obj1)
console.log(obj)
```


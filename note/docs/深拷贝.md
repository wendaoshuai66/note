#对深拷贝的研究


##深拷贝和浅拷贝的定义

深拷贝：拷贝实例；浅拷贝：拷贝引用（原对象）。

####说深拷贝和浅拷贝之前，我先去了解了下高程书上的JavaScript的变量类型：

基本类型：undefined、null、Boolean、number、string。变量直接按指存放在栈区内，可以直接访问，所以我们平时把字符串、数字的值赋值给新变量，相当于把值完全复制过去，新变量的改变不会影响旧变量。
  
引用类型：存放在堆区的对象，变量在栈区中保存的是一个指针地址。

例子

```
   let a = 123;
   let b = a;
   b = 456;
   console.log(a);//123
   console.log(b);//456
```

深拷贝和浅拷贝图解

![](https://wendaoshuai66.github.io/study/note/images/拷贝图解.png)


将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

话不多说，浅拷贝就不再多说，下面我们直入正题：

##乞丐版

在不使用第三方库的情况下，我们想要深拷贝一个对象，用的最多的就是下面这个方法。

```
JSON.parse(JSON.stringify());
```

这种写法非常简单，而且可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、拷贝正则、拷贝Date类型、循环引用等情况不行。

##基础版本1

```
//基础版本

function clone(target) {
    let cloneTarget = {};
    for (let i in target) {
        cloneTarget[i] = target[i]
    }
    return cloneTarget;
}
```


##基础版本2

创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性依次添加到新对象上，返回。

如果是深拷贝的话，考虑到我们要拷贝的对象是不知道有多少层深度的，我们可以用递归来解决问题，稍微改写上面的代码：

如果是原始类型，无需继续拷贝，直接返回

如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将需要克隆对象的属性执行深拷贝后依次添加到新对象上。

很容易理解，如果有更深层次的对象可以继续递归直到属性为原始类型，这样我们就完成了一个最简单的深拷贝


```

function clone(target) {
    if (typeof target === "object") {
        let cloneTarget = {};
        for (let i in target) {
            cloneTarget[i] = clone(target[i])
        }
        return cloneTarget;
    } else {
        return target;
    }
}
let obj = {
    a: 1,
    b: {
        c: {
            d: function() {
                console.log(1)
            }
        }
    }
}
let obj1 = clone(obj)
obj1['b']['c']['d'] = 'ee'
console.log(obj1)
console.log(obj)
```

##基础版本3

在上面的版本中，我们的初始化结果只考虑了普通的 object，下面我们只需要把初始化代码稍微一变，就可以兼容数组了：

```
function clone(target) {
            if (typeof target === "object") {
                let cloneTarget = Array.isArray(target) ? [] : {}
                for (let i in target) {
                    cloneTarget[i] = clone(target[i])
                }
                return cloneTarget;
            } else {
                return target
            }
        }
    let obj = {
        a: 1,
        b: {
            c: [1]
        }
    }
    let obj1 = clone(obj);
    obj1['b']['c'].push(2)
    console.log(obj)
    console.log(obj1)
```

##基础版本4

循环引用,一般我们很少会遇到这种情况，首先我们执行一个测试用例

```
function clone(target) {
    if (typeof target === "object") {
        let cloneTarget = Array.isArray(target) ? [] : {};
        for (let i in target) {
            cloneTarget[i] = clone(target[i])
        }
        return cloneTarget
    } else {
        return target;
    }
}

let obj = {
    a: 1,
    b: {
        c: [1]
    }
}
obj.obj = obj;
let obj1 = clone(obj);
obj1['b']['c'].push(2)
console.log(obj)
console.log(obj1)
```

可以看到下面的结果：


![](https://wendaoshuai66.github.io/study/note/images/循环引用.png)

很明显，因为递归进入死循环导致栈内存溢出了。

循环引用是一个不常见的现象，但是像react的dome节点的话很可能会出现循环引用，例如一个span节点中会出现一个span节点，这个很可能会相互引用上。

那么怎么解决呢？来看看这段代码

```
function clone(target, map = new Map()) {
    if (typeof target === "object") {
        let cloneTarget = Array.isArray(target) ? [] : {};
        if (map.get(target)) {
            return map.get(target)
        }
        map.set(target, cloneTarget)
        for (let i in target) {
            cloneTarget[i] = clone(target[i], map)
        }
        return cloneTarget
    } else {
        return target;
    }
}

let obj = {
    a: 1,
    b: {
        c: [1]
    }
}
obj.obj = obj;
let obj1 = clone(obj);
obj1['b']['c'].push(2)
console.log(obj)
console.log(obj1)
```

再来执行上面的测试用例：

![](https://wendaoshuai66.github.io/study/note/images/循环引用1.png)


可以看到，执行没有报错，且 target属性，变为了一个 Circular类型，即循环应用的意思。




